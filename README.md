NEXUS QUANTUM DEFENSE - é‡å­è®¡ç®—æ ¸å¿ƒåº“

ç‰ˆæœ¬: 1.5.0 (æ‹“æ‰‘æ„ŸçŸ¥APIç‰ˆ)
ä½œè€…: è·³èˆçš„ç«å…¬å­

ä¸€ä»½ä¸ºé«˜æ€§èƒ½é‡å­æ¨¡æ‹Ÿè€Œç”Ÿçš„æ ¸å¿ƒåº“ï¼Œè‡´åŠ›äºåœ¨çº¯æ€æ¨¡æ‹Ÿçš„æ•ˆç‡ä¸æ··åˆæ€æ¨¡æ‹Ÿçš„åŠŸèƒ½ä¹‹é—´å–å¾—æè‡´å¹³è¡¡ã€‚

![alt text](https://img.shields.io/badge/Python-3.8+-blue.svg)


![alt text](https://img.shields.io/badge/License-MIT-yellow.svg)


![alt text](https://img.shields.io/badge/build-passing-brightgreen.svg)

ğŸ“– ç®€ä»‹

quantum_core æ˜¯ä¸€ä¸ªåŠŸèƒ½å¼ºå¤§ã€è®¾è®¡ç²¾è‰¯çš„Pythoné‡å­è®¡ç®—æ¨¡æ‹Ÿåº“ã€‚å®ƒå°è£…äº†ä»åŸºç¡€çš„é‡å­æ€ã€é‡å­çº¿è·¯æ•°æ®ç»“æ„åˆ°é«˜æ€§èƒ½å¹¶è¡Œè®¡ç®—å¼•æ“çš„å…¨å¥—å·¥å…·ï¼Œæ—¨åœ¨ä¸ºé‡å­ç®—æ³•ç ”ç©¶ã€é‡å­æœºå™¨å­¦ä¹ å’Œå¸¦å™ªé‡å­ç³»ç»Ÿæ¨¡æ‹Ÿæä¾›ä¸€ä¸ªç¨³å®šã€é«˜æ•ˆä¸”æ˜“äºæ‰©å±•çš„åº•å±‚æ¡†æ¶ã€‚

æœ¬åº“çš„æ ¸å¿ƒè®¾è®¡å“²å­¦æ˜¯ â€œæƒ°æ€§æ±‚å€¼â€ ä¸ â€œåŒæ¨¡å¼æ¨¡æ‹Ÿå¼•æ“â€ çš„ç»“åˆã€‚åœ¨ç†æƒ³æƒ…å†µä¸‹ï¼ˆæ— å™ªå£°ï¼‰ï¼Œå®ƒé€šè¿‡æƒ°æ€§æ±‚å€¼æœ€å¤§åŒ–æ€§èƒ½ï¼Œä»…åœ¨éœ€è¦æ—¶æ‰æ‰§è¡Œæ˜‚è´µçš„æ€çŸ¢é‡è®¡ç®—ã€‚å½“å¼•å…¥éç›¸å¹²å™ªå£°æ—¶ï¼Œå®ƒèƒ½æ— ç¼ã€ä¸å¯é€†åœ°åˆ‡æ¢åˆ°åŠŸèƒ½æ›´å…¨é¢çš„å¯†åº¦çŸ©é˜µæ¨¡æ‹Ÿæ¨¡å¼ï¼Œä»è€Œå‡†ç¡®åœ°æè¿°æ··åˆæ€çš„æ¼”åŒ–ã€‚

âœ¨ æ ¸å¿ƒç‰¹æ€§

ğŸ§  æƒ°æ€§æ±‚å€¼ä¸åŒæ¨¡å¼å¼•æ“:

æ€çŸ¢é‡æ¨¡å¼ (Statevector): é»˜è®¤æ¨¡å¼ï¼Œç”¨äºçº¯æ€æ¨¡æ‹Ÿã€‚é—¨æ“ä½œä»…è¢«è®°å½•åœ¨ç”µè·¯ä¸­ï¼Œå®é™…è®¡ç®—è¢«æ¨è¿Ÿåˆ°æŸ¥è¯¢ç»“æœæ—¶ï¼Œæå¤§æå‡äº†æ„å»ºå¤æ‚çº¿è·¯çš„æ•ˆç‡ã€‚

å¯†åº¦çŸ©é˜µæ¨¡å¼ (Density Matrix): å½“åº”ç”¨éç›¸å¹²å™ªå£°ï¼ˆå¦‚é‡å­é€šé“ï¼‰æ—¶ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨ã€ä¸å¯é€†åœ°åˆ‡æ¢è‡³æ­¤æ¨¡å¼ï¼Œèƒ½å¤Ÿç²¾ç¡®æ¨¡æ‹Ÿæ··åˆæ€å’Œé€€ç›¸å¹²è¿‡ç¨‹ã€‚

âš¡ï¸ é«˜æ€§èƒ½è®¡ç®—åç«¯:

çº¯Pythonåç«¯: æ— ä»»ä½•ç¬¬ä¸‰æ–¹ä¾èµ–ï¼Œä¿è¯äº†æè‡´çš„ç¨³å®šæ€§å’Œè·¨å¹³å°å…¼å®¹æ€§ï¼Œæ˜¯é€»è¾‘éªŒè¯å’Œè°ƒè¯•çš„åŸºçŸ³ã€‚

CuPy GPUåŠ é€Ÿ: å¯é€‰çš„ CuPy åç«¯ï¼Œèƒ½å¤Ÿåˆ©ç”¨NVIDIA GPUè¿›è¡Œå¤§è§„æ¨¡å¹¶è¡Œè®¡ç®—ï¼Œæ˜¾è‘—åŠ é€Ÿå¤§å‹é‡å­ç³»ç»Ÿçš„æ¨¡æ‹Ÿã€‚

å†…ç½®CPUå¹¶è¡Œè®¡ç®—: å¯¹äºå¤§è§„æ¨¡çº¯Pythonæ¨¡æ‹Ÿï¼Œå†…ç½®äº†åŸºäº multiprocessing çš„å¹¶è¡Œè®¡ç®—åŸºç¡€è®¾æ–½ï¼Œå¯å……åˆ†åˆ©ç”¨å¤šæ ¸CPUèµ„æºåŠ é€Ÿç‰¹å®šé—¨æ“ä½œå’Œé…‰æ¼”åŒ–ã€‚

ğŸ›ï¸ ç¨³å¥çš„æ¶æ„è®¾è®¡:

ä¸­å¤®ç®—å­åº“ (QuantumOperatorLibrary): æ‰€æœ‰é‡å­é—¨çš„å®šä¹‰ï¼ˆçŸ©é˜µã€åˆ†è§£è§„åˆ™ã€ä¼˜åŒ–å†…æ ¸ï¼‰éƒ½é›†ä¸­ç®¡ç†ï¼Œæ˜¯å…¨ç³»ç»Ÿçš„â€œå•ä¸€äº‹å®æ¥æºâ€ï¼Œç¡®ä¿äº†è¡Œä¸ºçš„ä¸€è‡´æ€§å’Œå¯éªŒè¯æ€§ã€‚

å¯æ‰©å±•çš„å™ªå£°æ¨¡å‹: é€šè¿‡æŠ½è±¡åŸºç±» NoiseModel å®šä¹‰äº†æ¸…æ™°çš„å™ªå£°æ’ä»¶æ¥å£ï¼Œç”¨æˆ·å¯ä»¥è½»æ¾å®ç°è‡ªå®šä¹‰çš„ç›¸å¹²æˆ–éç›¸å¹²å™ªå£°æ¨¡å‹ï¼Œå¦‚ç¡¬ä»¶å™ªå£°ã€å…³è”å™ªå£°ç­‰ã€‚

æ‹“æ‰‘æ„ŸçŸ¥API (v1.5.0æ–°å¢): æ ¸å¿ƒAPI run_circuit_on_state æ¥æ”¶ topology å‚æ•°ï¼Œèƒ½å¤Ÿä¸å¤–éƒ¨ç¼–è¯‘å™¨ï¼ˆå¦‚ nexus_optimizerï¼‰æ— ç¼é›†æˆï¼Œå®ç°å¯¹çœŸå®ç¡¬ä»¶æ‹“æ‰‘çš„æ„ŸçŸ¥ä¼˜åŒ–ã€‚

ğŸ”‹ ä¸°å¯Œçš„åŠŸèƒ½é›†ä¸API:

å…¨é¢çš„é—¨æ“ä½œé›†: æ”¯æŒæ‰€æœ‰æ ‡å‡†å•æ¯”ç‰¹ã€å¤šæ¯”ç‰¹é—¨ï¼Œä»¥åŠé«˜çº§å¤šæ§åˆ¶é—¨ï¼ˆToffoli, MCX, MCZç­‰ï¼‰ã€‚

ç®—æ³•æ„å»ºå™¨ (AlgorithmBuilders): å†…ç½®äº†ç”¨äºå¿«é€Ÿæ„å»ºå¸¸ç”¨é‡å­ç®—æ³•ï¼ˆå¦‚QFT, QPE, Groverï¼‰å’ŒVQAæ‹Ÿè®¾ï¼ˆHardware-Efficient Ansatzï¼‰çš„ä¾¿æ·å·¥å…·ã€‚

å¼ºå¤§çš„åˆ†æèƒ½åŠ›: æä¾›äº†è®¡ç®—å“ˆå¯†é¡¿é‡æœŸæœ›å€¼ã€å†¯Â·è¯ºä¾æ›¼çº ç¼ ç†µã€å¸ƒæ´›èµ«çŸ¢é‡ã€è¾¹é™…æ¦‚ç‡ç­‰é«˜çº§åˆ†æå·¥å…·ã€‚

âš™ï¸ å®‰è£…

æœ¬æ ¸å¿ƒåº“è¢«è®¾è®¡ä¸ºä¸€ä¸ªç‹¬ç«‹çš„Pythonæ–‡ä»¶ï¼Œä¸ä¾èµ–ä»»ä½•éš¾ä»¥å®‰è£…çš„ç¬¬ä¸‰æ–¹åº“ï¼ˆCuPy é™¤å¤–ï¼‰ã€‚

åŸºç¡€å®‰è£… (ä»…CPU)

åªéœ€å°† quantum_core.py æ–‡ä»¶æ”¾ç½®åœ¨æ‚¨çš„é¡¹ç›®ç›®å½•ä¸­ï¼Œå³å¯ç›´æ¥å¯¼å…¥ä½¿ç”¨ã€‚

code
Python
download
content_copy
expand_less
import quantum_core as nq

æœ¬åº“éœ€è¦ Python 3.8 æˆ–æ›´é«˜ç‰ˆæœ¬ã€‚

å¯é€‰ï¼šå¯ç”¨GPUåŠ é€Ÿ

ä¸ºäº†è·å¾—æè‡´çš„æ¨¡æ‹Ÿæ€§èƒ½ï¼Œæ‚¨å¯ä»¥å®‰è£… CuPy åº“æ¥å¯ç”¨GPUåŠ é€Ÿã€‚è¯·æ ¹æ®æ‚¨çš„CUDAç‰ˆæœ¬é€‰æ‹©åˆé€‚çš„ CuPy ç‰ˆæœ¬è¿›è¡Œå®‰è£…ã€‚

ä¾‹å¦‚ï¼Œå¦‚æœæ‚¨çš„ç³»ç»Ÿå®‰è£…äº†CUDA 11.8ï¼Œå¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤ï¼š

code
Bash
download
content_copy
expand_less
pip install cupy-cuda11x

å¦‚æœæ‚¨çš„CUDAç‰ˆæœ¬ä¸åŒï¼Œè¯·å‚è€ƒ CuPyå®˜æ–¹å®‰è£…æŒ‡å— è¿›è¡Œå®‰è£…ã€‚

å®‰è£…å®Œæˆåï¼Œquantum_core å°†åœ¨å¯åŠ¨æ—¶è‡ªåŠ¨æ£€æµ‹åˆ° CuPy å¹¶ä¼˜å…ˆä½¿ç”¨GPUåç«¯ã€‚

ğŸš€ å¿«é€Ÿä¸Šæ‰‹

ä¸‹é¢æ˜¯ä¸€ä¸ªåˆ›å»ºè´å°”çº ç¼ æ€ |Î¦+âŸ© = (|00âŸ© + |11âŸ©)/âˆš2 å¹¶éªŒè¯å…¶æ¦‚ç‡åˆ†å¸ƒçš„ç®€å•ç¤ºä¾‹ã€‚

code
Python
download
content_copy
expand_less
import quantum_core as nq
import math

# 1. åˆ›å»ºä¸€ä¸ªåŒ…å«2ä¸ªé‡å­æ¯”ç‰¹çš„åˆå§‹é‡å­æ€ |00âŸ©
#    è¿™æ˜¯ä¸€ä¸ªæƒ°æ€§å¯¹è±¡ï¼Œæ­¤æ—¶æ²¡æœ‰è¿›è¡Œä»»ä½•å¤§è§„æ¨¡å†…å­˜åˆ†é…ã€‚
print("--- åˆ›å»ºåˆå§‹é‡å­æ€ ---")
initial_state = nq.create_quantum_state(num_qubits=2)
print(f"åˆå§‹æ€: {initial_state.num_qubits} qubits, æ¨¡å¼: {initial_state._simulation_mode}")

# 2. æ„å»ºä¸€ä¸ªç”¨äºåˆ¶å¤‡è´å°”æ€çš„é‡å­çº¿è·¯
print("\n--- æ„å»ºé‡å­çº¿è·¯ ---")
bell_circuit = nq.QuantumCircuit(num_qubits=2, description="Bell State Preparation")
bell_circuit.h(0)      # åœ¨ q0 ä¸Šåº”ç”¨ Hadamard é—¨
bell_circuit.cnot(0, 1) # åœ¨ (q0, q1) ä¸Šåº”ç”¨ CNOT é—¨
print(bell_circuit)

# 3. åœ¨åˆå§‹æ€ä¸Šæ‰§è¡Œçº¿è·¯ï¼Œå¾—åˆ°ä¸€ä¸ªæ–°çš„æ¼”åŒ–åçŠ¶æ€
#    æ­¤æ“ä½œéµå¾ªå‡½æ•°å¼ç¼–ç¨‹çš„ä¸å¯å˜æ€§åŸåˆ™ï¼ŒåŸå§‹çš„ initial_state ä¸ä¼šè¢«ä¿®æ”¹ã€‚
#    æ­¤æ—¶ï¼Œè®¡ç®—ä»ç„¶æ˜¯æƒ°æ€§çš„ã€‚
print("\n--- æ‰§è¡Œçº¿è·¯ (æƒ°æ€§) ---")
final_state = nq.run_circuit_on_state(initial_state, bell_circuit)
print(f"æœ€ç»ˆæ€: {final_state.num_qubits} qubits, æ¨¡å¼: {final_state._simulation_mode}")
print(f"æœ€ç»ˆæ€å†…éƒ¨çº¿è·¯æŒ‡ä»¤æ•°: {len(final_state.circuit.instructions)}")

# 4. è·å–æµ‹é‡æ¦‚ç‡åˆ†å¸ƒ
#    è¿™æ˜¯ç¬¬ä¸€ä¸ªéœ€è¦å®é™…è®¡ç®—ç»“æœçš„æ“ä½œï¼Œå®ƒå°†è§¦å‘å†…éƒ¨çš„â€œå±•å¼€è®¡ç®—â€ã€‚
print("\n--- è·å–ç»“æœ (è§¦å‘è®¡ç®—) ---")
probabilities = nq.get_measurement_probabilities(final_state)

# 5. éªŒè¯ç»“æœ
print(f"\næµ‹é‡æ¦‚ç‡: {probabilities}")
expected_probs = [0.5, 0.0, 0.0, 0.5]
assert all(math.isclose(p_actual, p_expected, abs_tol=1e-9) 
           for p_actual, p_expected in zip(probabilities, expected_probs))
print("âœ… éªŒè¯æˆåŠŸï¼æœ€ç»ˆæ€ä¸ºè´å°”æ€ |Î¦+âŸ©ã€‚")
æ ¸å¿ƒæ¦‚å¿µä¸æ¶æ„
ğŸ§  æƒ°æ€§æ±‚å€¼ä¸åŒæ¨¡å¼å¼•æ“

è¿™æ˜¯æœ¬åº“çš„æ ¸å¿ƒè®¾è®¡ã€‚

æƒ°æ€§æ±‚å€¼: åœ¨ statevector æ¨¡å¼ä¸‹ï¼Œå¯¹ QuantumState å¯¹è±¡åº”ç”¨é—¨æ“ä½œï¼ˆå¦‚ state.h(0)) ä¸ä¼šç«‹å³è®¡ç®—æ–°çš„æ€çŸ¢é‡ã€‚ç›¸åï¼Œå®ƒä»…å°†æŒ‡ä»¤è®°å½•åˆ°å†…éƒ¨çš„ QuantumCircuit ä¸­ã€‚è¿™ä½¿å¾—æ„å»ºåŒ…å«æ•°åƒä¸ªé—¨çš„å¤æ‚çº¿è·¯å‡ ä¹æ˜¯é›¶æˆæœ¬çš„ã€‚åªæœ‰å½“æ‚¨è¯·æ±‚ä¸€ä¸ªéœ€è¦å®Œæ•´çŠ¶æ€çš„ç»“æœæ—¶ï¼ˆä¾‹å¦‚ get_measurement_probabilities()ï¼‰ï¼Œç³»ç»Ÿæ‰ä¼šä¸€æ¬¡æ€§åœ°ã€é«˜æ•ˆåœ°æ‰§è¡Œæ‰€æœ‰ç´¯ç§¯çš„æŒ‡ä»¤æ¥è®¡ç®—æœ€ç»ˆçš„æ€çŸ¢é‡ã€‚

åŒæ¨¡å¼å¼•æ“:

statevector æ¨¡å¼: é»˜è®¤æ¨¡å¼ï¼Œä½¿ç”¨ä¸€ä¸ª (2^N,) çš„å¤æ•°å‘é‡æ¥è¡¨ç¤ºçº¯æ€ã€‚è®¡ç®—æ•ˆç‡é«˜ï¼Œå†…å­˜å ç”¨ç›¸å¯¹è¾ƒå°ã€‚

density_matrix æ¨¡å¼: å½“æ‚¨åº”ç”¨ä¸€ä¸ªéç›¸å¹²å™ªå£°é€šé“ï¼ˆä¾‹å¦‚ apply_quantum_channelï¼‰æ—¶ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨å°†æ€çŸ¢é‡ |ÏˆâŸ© è½¬æ¢ä¸ºå¯†åº¦çŸ©é˜µ Ï = |ÏˆâŸ©âŸ¨Ïˆ|ï¼Œå¹¶å°†æ¨¡å¼ä¸å¯é€†åœ°åˆ‡æ¢ä¸º density_matrixã€‚æ­¤åï¼Œæ‰€æœ‰æ“ä½œéƒ½å°†åœ¨ä¸€ä¸ª (2^N, 2^N) çš„å¯†åº¦çŸ©é˜µä¸Šè¿›è¡Œï¼Œè¿™è™½ç„¶è®¡ç®—æˆæœ¬æ›´é«˜ï¼Œä½†èƒ½å¤Ÿç²¾ç¡®åœ°æ¨¡æ‹Ÿæ··åˆæ€å’Œé€€ç›¸å¹²è¿‡ç¨‹ã€‚

code
Python
download
content_copy
expand_less
# æ¼”ç¤ºæ¨¡å¼åˆ‡æ¢
state = nq.create_quantum_state(1)
print(f"åˆå§‹æ¨¡å¼: {state._simulation_mode}") # -> statevector

# åº”ç”¨ä¸€ä¸ªéç›¸å¹²å™ªå£°é€šé“
state.apply_quantum_channel(
    channel_type='depolarizing', 
    target_qubits=[0], 
    params={'probability': 0.1}
)

print(f"åº”ç”¨å™ªå£°åçš„æ¨¡å¼: {state._simulation_mode}") # -> density_matrix
ğŸ›ï¸ é‡å­ç®—å­åº“ (QuantumOperatorLibrary)

QuantumOperatorLibrary æ˜¯æœ¬åº“çš„åŸºçŸ³ã€‚å®ƒæ˜¯ä¸€ä¸ªä¸­å¤®æ³¨å†Œä¸­å¿ƒï¼Œå­˜å‚¨äº†æ‰€æœ‰å†…ç½®é‡å­é—¨çš„å®Œæ•´å®šä¹‰ (OperatorDefinition)ã€‚æ¯ä¸ªå®šä¹‰éƒ½åŒ…å«ï¼š

æ•°å­¦è¡¨ç¤º: å›ºå®šçš„é…‰çŸ©é˜µï¼ˆå¦‚ X é—¨ï¼‰æˆ–ç”¨äºç”Ÿæˆé…‰çŸ©é˜µçš„å‡½æ•°ï¼ˆå¦‚ RX(Î¸)ï¼‰ã€‚

åˆ†è§£è§„åˆ™: å¯¹äºå¤åˆé—¨ï¼ˆå¦‚ SWAPï¼‰ï¼Œå®šä¹‰äº†å¦‚ä½•å°†å…¶åˆ†è§£ä¸ºæ›´åŸºç¡€çš„é—¨ã€‚

ä¼˜åŒ–å†…æ ¸: æŒ‡å‘ _StateVectorEntity æˆ– _DensityMatrixEntity å†…éƒ¨ä¸“é—¨ä¼˜åŒ–çš„ã€æ— éœ€æ„å»ºå…¨å±€çŸ©é˜µå³å¯æ‰§è¡Œæ“ä½œçš„é«˜æ€§èƒ½å‡½æ•°ã€‚

è¿™ç§è®¾è®¡ç¡®ä¿äº†å…¨ç³»ç»Ÿå¯¹é—¨æ“ä½œçš„è§£é‡Šå’Œæ‰§è¡Œæ˜¯ç»Ÿä¸€ã€å¯éªŒè¯ä¸”é«˜æ•ˆçš„ã€‚

âš¡ï¸ å¹¶è¡Œè®¡ç®—

æœ¬åº“å†…ç½®äº†åŸºäº multiprocessing çš„CPUå¹¶è¡Œè®¡ç®—æ¡†æ¶ï¼Œå¯ç”¨äºåŠ é€Ÿå¤§è§„æ¨¡ï¼ˆé€šå¸¸ > 12é‡å­æ¯”ç‰¹ï¼‰çš„çº¯Pythonæ¨¡æ‹Ÿã€‚

å¯ç”¨å¹¶è¡Œè®¡ç®—:
æ‚¨å¿…é¡»åœ¨è„šæœ¬çš„ä¸»æ‰§è¡Œå— (if __name__ == '__main__':) ä¸­æ˜¾å¼å¯ç”¨å¹¶è¡Œæ¨¡å¼ã€‚

code
Python
download
content_copy
expand_less
import quantum_core as nq
import sys

if __name__ == '__main__':
    # å¯ç”¨å¹¶è¡Œè®¡ç®—ï¼Œè‡ªåŠ¨æ£€æµ‹CPUæ ¸å¿ƒæ•°
    nq.enable_parallelism()

    try:
        # åœ¨è¿™é‡Œè¿è¡Œæ‚¨çš„å¤§è§„æ¨¡æ¨¡æ‹Ÿ
        state = nq.create_quantum_state(14)
        state.h(0) # è¿™ä¸ªæ“ä½œåœ¨å±•å¼€æ—¶å¯èƒ½ä¼šè¢«å¹¶è¡ŒåŒ–
        
        # ... æ›´å¤šæ“ä½œ ...
        
        # è§¦å‘è®¡ç®—
        probs = nq.get_measurement_probabilities(state)
        print("å¤§è§„æ¨¡æ¨¡æ‹Ÿå®Œæˆã€‚")

    finally:
        # åœ¨ç¨‹åºç»“æŸå‰ä¼˜é›…åœ°å…³é—­å¹¶è¡Œæ± 
        nq.disable_parallelism()
ğŸ“š å…¬å…± API å‚è€ƒ

ä»¥ä¸‹æ˜¯ quantum_core æä¾›çš„æ ¸å¿ƒå…¬å…±APIå‡½æ•°ã€‚

create_quantum_state(num_qubits)

åˆ›å»ºä¸€ä¸ªå¤„äº |0...0âŸ© æ€çš„åˆå§‹æƒ°æ€§é‡å­æ€ã€‚

å‚æ•°	ç±»å‹	æè¿°
num_qubits	int	è¦åˆ›å»ºçš„é‡å­æ€çš„æ¯”ç‰¹æ•°ã€‚

è¿”å›: ä¸€ä¸ªæ–°çš„ QuantumState å®ä¾‹ã€‚

run_circuit_on_state(state, circuit, noise_model, topology)

åœ¨ä¸€ä¸ªé‡å­æ€ä¸Šæ‰§è¡Œä¸€ä¸ªé‡å­çº¿è·¯ï¼Œè¿”å›ä¸€ä¸ªè¡¨ç¤ºæ¼”åŒ–åçŠ¶æ€çš„æ–°é‡å­æ€å®ä¾‹ã€‚

å‚æ•°	ç±»å‹	æè¿°	é»˜è®¤å€¼
state	QuantumState	åˆå§‹é‡å­æ€ã€‚	
circuit	QuantumCircuit	è¦æ‰§è¡Œçš„é‡å­çº¿è·¯ã€‚	
noise_model	Optional[NoiseModel]	å¯é€‰çš„å™ªå£°æ¨¡å‹ã€‚	None
topology	Optional[Dict]	å¯é€‰çš„ç¡¬ä»¶æ‹“æ‰‘å›¾ã€‚	None

è¿”å›: æ¼”åŒ–åçš„æ–° QuantumState å®ä¾‹ã€‚

get_state_data(state, format)

å®‰å…¨åœ°ä»ä¸€ä¸ª QuantumState å¯¹è±¡ä¸­æå–åº•å±‚çš„çŠ¶æ€æ•°æ®ï¼ˆæ€çŸ¢é‡æˆ–å¯†åº¦çŸ©é˜µï¼‰ã€‚æ­¤å‡½æ•°ä¼šæ ¹æ®éœ€è¦è§¦å‘å±•å¼€è®¡ç®—ã€‚

å‚æ•°	ç±»å‹	æè¿°	é»˜è®¤å€¼
state	QuantumState	è¦æå–æ•°æ®çš„é‡å­æ€ã€‚	
format	str	è¿”å›æ•°æ®çš„æ ¼å¼ã€‚ç›®å‰ä»…æ”¯æŒ 'python_list'ã€‚	'python_list'

è¿”å›: List[complex] (æ€çŸ¢é‡) æˆ– List[List[complex]] (å¯†åº¦çŸ©é˜µ)ã€‚

get_measurement_probabilities(state)

è·å–ä¸€ä¸ªé‡å­æ€æ‰€æœ‰è®¡ç®—åŸºçš„æµ‹é‡æ¦‚ç‡ã€‚

å‚æ•°	ç±»å‹	æè¿°
state	QuantumState	è¦åˆ†æçš„é‡å­æ€ã€‚

è¿”å›: List[float]ï¼Œä¸€ä¸ªåŒ…å«æ‰€æœ‰æµ‹é‡æ¦‚ç‡çš„åˆ—è¡¨ã€‚

calculate_hamiltonian_expectation_value(state, hamiltonian)

è®¡ç®—ç»™å®šå“ˆå¯†é¡¿é‡åœ¨å½“å‰é‡å­æ€ä¸‹çš„æœŸæœ›å€¼ã€‚

å‚æ•°	ç±»å‹	æè¿°
state	QuantumState	è¦åˆ†æçš„é‡å­æ€ã€‚
hamiltonian	List[PauliString]	è¡¨ç¤ºå“ˆå¯†é¡¿é‡çš„ PauliString åˆ—è¡¨ã€‚

è¿”å›: floatï¼Œå“ˆå¯†é¡¿é‡çš„æœŸæœ›å€¼ã€‚

get_effective_unitary(circuit, backend_choice)

è®¡ç®—ç»™å®š QuantumCircuit å¯¹åº”çš„å…¨å±€æœ‰æ•ˆé…‰çŸ©é˜µã€‚

å‚æ•°	ç±»å‹	æè¿°	é»˜è®¤å€¼
circuit	QuantumCircuit	è¦è®¡ç®—é…‰çŸ©é˜µçš„çº¿è·¯ã€‚	
backend_choice	str	ç”¨äºè®¡ç®—çš„åç«¯ ('auto', 'pure_python', 'cupy')ã€‚	'auto'

è¿”å›: é…‰çŸ©é˜µ (Python list æˆ– cupy.ndarray)ã€‚

ğŸ”¬ é«˜çº§ç”¨æ³•
ä½¿ç”¨å™ªå£°æ¨¡å‹

æœ¬åº“æ”¯æŒé€šè¿‡ NoiseModel å­ç±»æ¥æ¨¡æ‹Ÿå¸¦å™ªé‡å­è®¡ç®—ã€‚

code
Python
download
content_copy
expand_less
# 1. å®šä¹‰ä¸€ä¸ªæ¨¡æ‹ŸçœŸå®ç¡¬ä»¶å™ªå£°çš„æ ¡å‡†æ•°æ®
fake_calib = {
    'qubits': {
        0: {'T1': 50e-6, 'T2': 70e-6, 'readout_error': 0.01},
    },
    'gates': {
        'h': {'duration': 50e-9, 'error_rate': 0.001}, # 50ns H-gate, 0.1% å»æåŒ–é”™è¯¯
    }
}

# 2. å®ä¾‹åŒ–é¢„ç½®çš„ç¡¬ä»¶å™ªå£°æ¨¡å‹
noise_model = nq.PrebuiltNoiseModels.HardwareBackend(fake_calib)

# 3. åˆ›å»ºåˆå§‹æ€å’Œçº¿è·¯
state = nq.create_quantum_state(1)
circuit = nq.QuantumCircuit(1)
circuit.h(0)

# 4. åœ¨è¿è¡Œçº¿è·¯æ—¶ä¼ å…¥å™ªå£°æ¨¡å‹
noisy_state = nq.run_circuit_on_state(state, circuit, noise_model=noise_model)

# 5. éªŒè¯çŠ¶æ€å·²å˜ä¸ºæ··åˆæ€
assert noisy_state._simulation_mode == 'density_matrix'
purity = nq.calculate_state_purity(noisy_state) # å‡è®¾æœ‰è¿™æ ·ä¸€ä¸ªAPI
print(f"å¸¦å™ªçŠ¶æ€çš„çº¯åº¦: {purity:.4f}") # çº¯åº¦åº”å°äº1
ç®—æ³•æ„å»ºå™¨

ä½¿ç”¨ AlgorithmBuilders å¯ä»¥å¿«é€Ÿç”Ÿæˆå¤æ‚ç®—æ³•çš„çº¿è·¯ã€‚

code
Python
download
content_copy
expand_less
# æ„å»ºä¸€ä¸ª3æ¯”ç‰¹çš„é‡å­å‚…é‡Œå¶å˜æ¢(QFT)çº¿è·¯
qft_circuit = nq.AlgorithmBuilders.build_qft_circuit(num_qubits=3)

print("--- 3-qubit QFT Circuit ---")
print(qft_circuit)

# æ„å»ºä¸€ä¸ªç”¨äºVQAçš„ç¡¬ä»¶é«˜æ•ˆæ‹Ÿè®¾
params = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8]
ansatz = nq.AlgorithmBuilders.build_hardware_efficient_ansatz(
    num_qubits=2,
    depth=2,
    parameters=params,
    entanglement_type='circular'
)
print("\n--- Hardware-Efficient Ansatz ---")
print(ansatz)
é…ç½®æ ¸å¿ƒåº“

æ‚¨å¯ä»¥åœ¨è¿è¡Œæ—¶é€šè¿‡ configure_quantum_core å‡½æ•°è°ƒæ•´åº“çš„è¡Œä¸ºã€‚

code
Python
download
content_copy
expand_less
# å¼ºåˆ¶ä½¿ç”¨çº¯Pythonåç«¯ï¼Œå¹¶è®¾ç½®æœ€å¤§é‡å­æ¯”ç‰¹æ•°ä¸Šé™
nq.configure_quantum_core({
    "BACKEND_CHOICE": "pure_python",
    "MAX_QUBITS": 10,
    "MAX_SYSTEM_RAM_GB_LIMIT": 16 # æ‰‹åŠ¨è®¾ç½®å†…å­˜ä¸Šé™ä¸º16GB
})
ğŸ§ª æµ‹è¯•

æœ¬æ–‡ä»¶åŒ…å«ä¸€ä¸ªå…¨é¢çš„è‡ªæµ‹è¯•å¥—ä»¶ã€‚è¦è¿è¡Œæµ‹è¯•ï¼Œåªéœ€ç›´æ¥æ‰§è¡Œæ­¤è„šæœ¬ï¼š

code
Bash
download
content_copy
expand_less
python quantum_core.py

æµ‹è¯•å¥—ä»¶å°†è‡ªåŠ¨åœ¨å¯ç”¨çš„åç«¯ï¼ˆPure Python å’Œ/æˆ– CuPyï¼‰ä¸Šè¿è¡Œï¼Œå¹¶éªŒè¯æ‰€æœ‰æ ¸å¿ƒåŠŸèƒ½ã€ç®—æ³•æ„å»ºå™¨å’Œå™ªå£°æ¨¡å‹çš„æ­£ç¡®æ€§ã€‚æµ‹è¯•é‡‡ç”¨â€œå¿«é€Ÿå¤±è´¥â€ç­–ç•¥ï¼Œä»»ä½•ä¸€ä¸ªæµ‹è¯•å¤±è´¥éƒ½ä¼šç«‹å³ä¸­æ­¢æ•´ä¸ªæµ‹è¯•æµç¨‹ã€‚

ğŸ“œ ç‰ˆæœ¬å†å²
v1.5.0 - æ‹“æ‰‘æ„ŸçŸ¥APIç‰ˆ

API å‡çº§: å…¬å…± API run_circuit_on_state å’Œç›¸å…³å†…éƒ¨æ–¹æ³•ç°åœ¨æ¥æ”¶ topology å‚æ•°ï¼Œä»¥å®ç°å¯¹é‡å­å­ç¨‹åºçš„æ‹“æ‰‘æ„ŸçŸ¥ä¼˜åŒ–ã€‚

æ¶æ„é‡æ„: å½»åº•ç§»é™¤äº† get_effective_unitary ä¸­çš„çŒ´å­è¡¥ä¸ï¼Œé‡‡ç”¨å†…ç½®çš„æ¨¡å¼æ„ŸçŸ¥æ‰§è¡Œï¼Œæé«˜äº†ä»£ç çš„å¥å£®æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚

å™ªå£°æ¨¡å‹æ‰©å±•: å¼•å…¥äº† CorrelatedNoise æ¨¡å‹ï¼Œç”¨äºæ¨¡æ‹Ÿä¸²æ‰°ç­‰éå±€éƒ¨æ•ˆåº”ã€‚

é€»è¾‘ä¿®å¤: ä¿®æ­£äº†ç›¸å¹²å™ªå£°çš„åº”ç”¨é€»è¾‘ï¼Œç¡®ä¿å…¶åªä½œç”¨äºæ—‹è½¬é—¨çš„æ—‹è½¬è§’åº¦ã€‚

å†…æ ¸è°ƒåº¦ä¼˜åŒ–: _StateVectorEntity å†…éƒ¨æ”¹ç”¨è°ƒåº¦å­—å…¸æ¥ç®¡ç†ä¼˜åŒ–å†…æ ¸ï¼Œæé«˜äº†ä»£ç çš„å¯è¯»æ€§å’Œå¯æ‰©å±•æ€§ã€‚

ğŸ‘¤ ä½œè€…

è·³èˆçš„ç«å…¬å­

ğŸ“„ è®¸å¯è¯

æœ¬é¡¹ç›®é‡‡ç”¨ MIT è®¸å¯è¯ã€‚è¯¦æƒ…è¯·è§ LICENSE æ–‡ä»¶ã€‚